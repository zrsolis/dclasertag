//
// automatically generated by spin2cpp v1.05 on Sun Aug  3 17:30:34 2014
// ./spin2cpp ../goonie/Simple_Numbers.spin 
//

#include <stdlib.h>
#include <propeller.h>
#include "Simple_Numbers.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#endif

INLINE__ int32_t Min__(int32_t a, int32_t b) { return a < b ? a : b; }
INLINE__ int32_t Max__(int32_t a, int32_t b) { return a > b ? a : b; }
INLINE__ int32_t Rotl__(uint32_t a, uint32_t b) { return (a<<b) | (a>>(32-b)); }
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b) { return (a>>b) | (a<<(32-b)); }
INLINE__ int32_t Lookup__(int32_t x, int32_t b, int32_t a[], int32_t n) { int32_t i = (x)-(b); return ((unsigned)i >= n) ? 0 : (a)[i]; }

int32_t Simple_Numbers::Dec(int32_t Value)
{
  Clrstr((int32_t)(&Nstr), Max_len);
  return Decstr(Value);
}

int32_t Simple_Numbers::Decf(int32_t Value, int32_t Width)
{
  int32_t	T_val, Field;
  Clrstr((int32_t)(&Nstr), Max_len);
  Width = (Min__((Max__(1, Width)), 0x3f));
  T_val = (abs(Value));
  Field = 0;
  while (T_val > 0) {
    (Field++);
    T_val = (T_val / 10);
  }
  Field = (Max__(Field, 1));
  if (Value < 0) {
    (Field++);
  }
  if (Field < Width) {
    {
      int32_t _idx__0000;
      int32_t _limit__0001 = (Width - Field);
      for(_idx__0000 = 1; _idx__0000 <= _limit__0001; (_idx__0000 = (_idx__0000 + 1))) {
        Nstr[(Idx++)] = ' ';
      }
    }
  }
  return Decstr(Value);
}

int32_t Simple_Numbers::Decx(int32_t Value, int32_t Digits)
{
  int32_t	Div;
  Clrstr((int32_t)(&Nstr), Max_len);
  Digits = (Min__((Max__(1, Digits)), 10));
  if (Value < 0) {
    Value = (-Value);
    Nstr[(Idx++)] = '-';
  }
  Div = 1000000000;
  if (Digits < 10) {
    {
      int32_t _idx__0002;
      int32_t _limit__0003 = (10 - Digits);
      for(_idx__0002 = 1; _idx__0002 <= _limit__0003; (_idx__0002 = (_idx__0002 + 1))) {
        Div = (Div / 10);
      }
    }
  }
  Value = (Value % (Div * 10));
  {
    int32_t _idx__0004;
    int32_t _limit__0005 = Digits;
    for(_idx__0004 = 1; _idx__0004 <= _limit__0005; (_idx__0004 = (_idx__0004 + 1))) {
      Nstr[(Idx++)] = ((Value / Div) + '0');
      Value = (Value % Div);
      Div = (Div / 10);
    }
  }
  return (int32_t)(&Nstr);
}

int32_t Simple_Numbers::Hex(int32_t Value, int32_t Digits)
{
  Clrstr((int32_t)(&Nstr), Max_len);
  return Hexstr(Value, Digits);
}

int32_t Simple_Numbers::Ihex(int32_t Value, int32_t Digits)
{
  Clrstr((int32_t)(&Nstr), Max_len);
  Nstr[(Idx++)] = '$';
  return Hexstr(Value, Digits);
}

int32_t Simple_Numbers::Bin(int32_t Value, int32_t Digits)
{
  Clrstr((int32_t)(&Nstr), Max_len);
  return Binstr(Value, Digits);
}

int32_t Simple_Numbers::Ibin(int32_t Value, int32_t Digits)
{
  Clrstr((int32_t)(&Nstr), Max_len);
  Nstr[(Idx++)] = '%';
  return Binstr(Value, Digits);
}

int32_t Simple_Numbers::Clrstr(int32_t Straddr, int32_t Size)
{
  memset( (void *)Straddr, 0, 1*(Size));
  Idx = 0;
  return 0;
}

int32_t Simple_Numbers::Decstr(int32_t Value)
{
  int32_t	Div, Z_pad;
  if (Value < 0) {
    Value = (-Value);
    Nstr[(Idx++)] = '-';
  }
  Div = 1000000000;
  Z_pad = 0;
  {
    int32_t _idx__0006;
    for(_idx__0006 = 1; _idx__0006 <= 10; (_idx__0006 = (_idx__0006 + 1))) {
      if (Value >= Div) {
        Nstr[(Idx++)] = ((Value / Div) + '0');
        Value = (Value % Div);
        Z_pad = -1;
      } else {
        if ((Z_pad) || (Div == 1)) {
          Nstr[(Idx++)] = '0';
        }
      }
      Div = (Div / 10);
    }
  }
  return (int32_t)(&Nstr);
}

int32_t Simple_Numbers::Hexstr(int32_t Value, int32_t Digits)
{
  static int32_t look__0007[] = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

  Digits = (Min__((Max__(1, Digits)), 8));
  Value = (Value << ((8 - Digits) << 2));
  {
    int32_t _idx__0008;
    int32_t _limit__0009 = Digits;
    for(_idx__0008 = 1; _idx__0008 <= _limit__0009; (_idx__0008 = (_idx__0008 + 1))) {
      Nstr[(Idx++)] = Lookup__(((Value = (Rotl__(Value, 4))) & 0xf), 0, look__0007, 16);
    }
  }
  return (int32_t)(&Nstr);
}

int32_t Simple_Numbers::Binstr(int32_t Value, int32_t Digits)
{
  Digits = (Min__((Max__(1, Digits)), 32));
  Value = (Value << (32 - Digits));
  {
    int32_t _idx__0010;
    int32_t _limit__0011 = Digits;
    for(_idx__0010 = 1; _idx__0010 <= _limit__0011; (_idx__0010 = (_idx__0010 + 1))) {
      Nstr[(Idx++)] = (((Value = (Rotl__(Value, 1))) & 0x1) + '0');
    }
  }
  return (int32_t)(&Nstr);
}

