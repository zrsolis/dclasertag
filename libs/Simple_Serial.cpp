//
// automatically generated by spin2cpp v1.05 on Sat May 10 13:28:09 2014
// ./spin2cpp Simple_Serial.spin 
//

#include <stdlib.h>
#include <propeller.h>
#include "Simple_Serial.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#endif

INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
int32_t Simple_Serial::Init(int32_t Rxpin, int32_t Txpin, int32_t Baud)
{
  Finalize();
  Rxokay = -(Rxpin > (-1));
  Txokay = -(Txpin > (-1));
  Sin = (Rxpin & 0x1f);
  Sout = (Txpin & 0x1f);
  Inverted = -(Baud < 0);
  Bittime = (CLKFREQ / (abs(Baud)));
  return (Rxokay | Txokay);
}

int32_t Simple_Serial::Finalize(void)
{
  if (Txokay) {
    DIRA &= ~(1<<Sout);
  }
  Rxokay = (Txokay = 0);
  return 0;
}

int32_t Simple_Serial::Rx(void)
{
  int32_t	T;
  int32_t Rxbyte = 0;
  if (Rxokay) {
    DIRA &= ~(1<<Sin);
    waitpeq((Inverted & ((1<<Sin))), ((1<<Sin)));
    T = (CNT + (Shr__(Bittime, 1)));
    {
      int32_t _idx__0000;
      for(_idx__0000 = 1; _idx__0000 <= 8; (_idx__0000 = (_idx__0000 + 1))) {
        waitcnt((T = (T + Bittime)));
        Rxbyte = ((((INA >> Sin) & 0x1) << 7) | (Shr__(Rxbyte, 1)));
      }
    }
    waitcnt((T + Bittime));
    Rxbyte = ((Rxbyte ^ Inverted) & 0xff);
  }
  return Rxbyte;
}

int32_t Simple_Serial::Tx(int32_t Txbyte)
{
  int32_t	T;
  if (Txokay) {
    OUTA = ((OUTA & (~(1 << Sout))) | (((~Inverted) & 0x1) << Sout));
    DIRA = ((DIRA & (~(1 << Sout))) | (1 << Sout));
    Txbyte = (((Txbyte | 0x100) << 2) ^ Inverted);
    T = CNT;
    {
      int32_t _idx__0001;
      for(_idx__0001 = 1; _idx__0001 <= 10; (_idx__0001 = (_idx__0001 + 1))) {
        waitcnt((T = (T + Bittime)));
        OUTA = ((OUTA & (~(1 << Sout))) | ((((Txbyte = (Shr__(Txbyte, 1))) & 0x1) & 0x1) << Sout));
      }
    }
    if (Sout == Sin) {
      DIRA &= ~(1<<Sout);
    }
  }
  return 0;
}

int32_t Simple_Serial::Str(int32_t Straddr)
{
  if (Txokay) {
    {
      int32_t _idx__0002;
      int32_t _limit__0003 = strlen((char *) Straddr);
      for(_idx__0002 = 1; _idx__0002 <= _limit__0003; (_idx__0002 = (_idx__0002 + 1))) {
        Tx(((uint8_t *)(Straddr++))[0]);
      }
    }
  }
  return 0;
}

